https://github.com/Crypto-Cat/CTF/tree/main/pwn -> for exploit file models
https://gist.github.com/caprinux/f1885531687dec526580f9127bdae6bc -> pwn walkthru
https://github.com/hoppersroppers/nightmare/tree/master/modules --> course to go though
## Pre analysis
`checksec` -> sees if it has protections prob doesnt
`rabin2 -z` but i cant get this to work
`rabin2 -i`
`chmod +x <file>` --> to give executable permissions


## Buffer overflow
modify variables or function calls

*recognition*
When user input is not checked or constrained you can usually overflow
e.g. `scanf("%s", arr)` --> input can be really big and overflow out of `arr` variable

*the stack*
`ebp` --> points to the bottom of the stack
`esp` --> stack pointer
`eip` --> instruction pointer
essentially the area between `esp` and `ebp` is the **stack frame** used for calculations
`x/24wx $esp` --> print stack

*calling convention*
convention for how parameters are taken for function calls (character buffer)

*find the buffer*
2. disass main
4. `cyclic 100` -> outside of the run
5. u get segfault when you overwrite the return address
6. find the overwritten value at variable
7. `cyclic -l (value)` -> get the offset
A is just 0x41 so look for that in the stack, a is 0x61

*overflow - overwrite var*
find the stack before
`python3 -c 'print("A"*(number)')` --> print A a bunch of times (do this OUTSIDE of GDB)

*overflow - overwrite RIP*
in the stack, saved return address is stored at `[rbp+8]` and is run when `ret` is called by pushing it into `rip`
1. find the buffer between input and `rbp` (will shown gdb-pwndbg) +8 to that
2. find the address of the function to run with `disass`
3. overwrite the return address with the function address

*overflow pass in parameters*  ->ROP CHAINS
in 64 bit x86, the calling convention is `func(RDI, RSI, RDX, RCX, R8, R9)`
in order to control the `rdi` value, you can find a ROP chain that does smt like 
`pop rdi ; ret ; <RDI_VALUE>`
so the rdi value will be the last value in the stack

*finding adresses of variables/functions*
`x/gx shell` -> find the memory address


## Stack Guard
when you see stuff like `gs` it means the programme protects against stack smashing by loading random values from the **Thread control block** 
```
main:
; Set up the stack
        pushl   %ebp
        movl    %esp, %ebp
        andl    $-16, %esp
        subl    $16, %esp

; Set up stack guard
        movl    %gs:20, %eax       ; load random value gs:20 = eax?
        movl    %eax, 12(%esp)     ; store value as a guard variable. eax=esp+12
        xorl    %eax, %eax         ; make sure that noone can read the random value afterwards, %eax = 0
;...
; strcpy ommitted (this overwrites 12(%esp) since the string is too large for the buffer)
;...

; Check stack guard against value from TCB
        movl    12(%esp), %edx     ; load previously stored value from stack esp+12 = edx
        xorl    %gs:20, %edx       ; check if still the same
        je      .L3                ; yes, then fine
        call    __stack_chk_fail   ; print error message and abort()
.L3:
        leave
        ret
```

## Ropper gadgets
https://en.wikipedia.org/wiki/Return-oriented_programming
`ropper -f (file)`
find gadgets that run commands?

## gdb
https://exploit-notes.hdks.org/exploit/reverse-engineering/reverse-engineering-with-gdb/
https://c12yptonic.github.io/ctf-writeups/ctfs/deconstructf21#scraps-
http://security.cs.pub.ro/hexcellents/wiki/kb/toolset/gdb --> cheat sheet!

`gdb (destination)`
`disassemble main`
`set disassembly-flavour intel`
`b *main` --> set breakpoints
`info registers`
`info proc mappings` -> memory?
`info frame` -> rip
`si` --> step one register
`ni` --> step to next funtion call
`set (var)=(value)` --> var can be memory with type specified e.g. `set {int}0x83040=4`
`define (func)`
`x/[_Length_][_Format_] [_Address expression_]` --.> displays memory content at address e.g `x/24wx` --> 24 content in hex
`run`
`continue`
`del` -> remove breakpoints
`search-pattern` -> find your input in memory

Hook stop (function that runs at every break)
```
define hook-stop
info registers
x/24wx $esp
x/2i $eip
end
```

==use pwndbg instead?==


## Radare2
`radare2 (exe)`
1. `aaaa`
2. `afl`
(idk what this does)



## Python pwn
https://guyinatuxedo.github.io/02-intro_tooling/pwntools/index.html

`from pwn import *`
`target = process("./file")`
`target = remote(server, port)`

`target.sendline(payload)`
`target.interactive()` -> if trying to interact with a shell

`gdb.attach(p)` -> used for debugging by attaching the gdb
(always run the process first not remote to find errors)

*stack alignment*
https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/stack-alignment
tldr just add another `ret` to fix error


## Format String Attack
when input from user is not validated and printed directly